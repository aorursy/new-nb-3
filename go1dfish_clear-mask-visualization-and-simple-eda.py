import numpy as np # linear algebra

import pandas as pd

pd.set_option("display.max_rows", 101)

import os

print(os.listdir("../input"))

import cv2

import json

import matplotlib.pyplot as plt


plt.rcParams["font.size"] = 15

import seaborn as sns

from collections import Counter

from PIL import Image

import math

import seaborn as sns

from collections import defaultdict

from pathlib import Path

import cv2

from tqdm import tqdm
input_dir = "../input/"
train_df = pd.read_csv("../input/train.csv")

sample_df = pd.read_csv("../input/sample_submission.csv")
train_df.head()
sample_df.head()
class_dict = defaultdict(int)



kind_class_dict = defaultdict(int)



no_defects_num = 0

defects_num = 0



for col in range(0, len(train_df), 4):

    img_names = [str(i).split("_")[0] for i in train_df.iloc[col:col+4, 0].values]

    if not (img_names[0] == img_names[1] == img_names[2] == img_names[3]):

        raise ValueError

        

    labels = train_df.iloc[col:col+4, 1]

    if labels.isna().all():

        no_defects_num += 1

    else:

        defects_num += 1

    

    kind_class_dict[sum(labels.isna().values == False)] += 1

        

    for idx, label in enumerate(labels.isna().values.tolist()):

        if label == False:

            class_dict[idx+1] += 1
print("the number of images with no defects: {}".format(no_defects_num))

print("the number of images with defects: {}".format(defects_num))
fig, ax = plt.subplots()

sns.barplot(x=list(class_dict.keys()), y=list(class_dict.values()), ax=ax)

ax.set_title("the number of images for each class")

ax.set_xlabel("class")

class_dict
fig, ax = plt.subplots()

sns.barplot(x=list(kind_class_dict.keys()), y=list(kind_class_dict.values()), ax=ax)

ax.set_title("Number of classes included in each image");

ax.set_xlabel("number of classes in the image")

kind_class_dict
train_size_dict = defaultdict(int)

train_path = Path("../input/train_images/")



for img_name in train_path.iterdir():

    img = Image.open(img_name)

    train_size_dict[img.size] += 1
train_size_dict
test_size_dict = defaultdict(int)

test_path = Path("../input/test_images/")



for img_name in test_path.iterdir():

    img = Image.open(img_name)

    test_size_dict[img.size] += 1
test_size_dict
palet = [(249, 192, 12), (0, 185, 241), (114, 0, 218), (249,50,12)]
def name_and_mask(start_idx):

    col = start_idx

    img_names = [str(i).split("_")[0] for i in train_df.iloc[col:col+4, 0].values]

    if not (img_names[0] == img_names[1] == img_names[2] == img_names[3]):

        raise ValueError



    labels = train_df.iloc[col:col+4, 1]

    mask = np.zeros((256, 1600, 4), dtype=np.uint8)



    for idx, label in enumerate(labels.values):

        if label is not np.nan:

            mask_label = np.zeros(1600*256, dtype=np.uint8)

            label = label.split(" ")

            positions = map(int, label[0::2])

            length = map(int, label[1::2])

            for pos, le in zip(positions, length):

                mask_label[pos-1:pos+le-1] = 1

            mask[:, :, idx] = mask_label.reshape(256, 1600, order='F')

    return img_names[0], mask
def show_mask_image(col):

    name, mask = name_and_mask(col)

    img = cv2.imread(str(train_path / name))

    fig, ax = plt.subplots(figsize=(15, 15))



    for ch in range(4):

        contours, _ = cv2.findContours(mask[:, :, ch], cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)

        for i in range(0, len(contours)):

            cv2.polylines(img, contours[i], True, palet[ch], 2)

    ax.set_title(name)

    ax.imshow(img)

    plt.show()
fig, ax = plt.subplots(1, 4, figsize=(15, 5))

for i in range(4):

    ax[i].axis('off')

    ax[i].imshow(np.ones((50, 50, 3), dtype=np.uint8) * palet[i])

    ax[i].set_title("class color: {}".format(i+1))

fig.suptitle("each class colors")



plt.show()
idx_no_defect = []

idx_class_1 = []

idx_class_2 = []

idx_class_3 = []

idx_class_4 = []

idx_class_multi = []

idx_class_triple = []



for col in range(0, len(train_df), 4):

    img_names = [str(i).split("_")[0] for i in train_df.iloc[col:col+4, 0].values]

    if not (img_names[0] == img_names[1] == img_names[2] == img_names[3]):

        raise ValueError

        

    labels = train_df.iloc[col:col+4, 1]

    if labels.isna().all():

        idx_no_defect.append(col)

    elif (labels.isna() == [False, True, True, True]).all():

        idx_class_1.append(col)

    elif (labels.isna() == [True, False, True, True]).all():

        idx_class_2.append(col)

    elif (labels.isna() == [True, True, False, True]).all():

        idx_class_3.append(col)

    elif (labels.isna() == [True, True, True, False]).all():

        idx_class_4.append(col)

    elif labels.isna().sum() == 1:

        idx_class_triple.append(col)

    else:

        idx_class_multi.append(col)
for idx in idx_no_defect[:5]:

    show_mask_image(idx)
for idx in idx_class_1[:5]:

    show_mask_image(idx)
for idx in idx_class_2[:5]:

    show_mask_image(idx)
for idx in idx_class_3[:5]:

    show_mask_image(idx)
for idx in idx_class_4[:5]:

    show_mask_image(idx)
for idx in idx_class_multi[:5]:

    show_mask_image(idx)
for idx in idx_class_triple:

    show_mask_image(idx)
for col in tqdm(range(0, len(train_df), 4)):

    name, mask = name_and_mask(col)

    if (mask.sum(axis=2) >= 2).any():

        show_mask_image(col)